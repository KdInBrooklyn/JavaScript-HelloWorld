/**
 * Created by LiSen on 2017/6/27.
 */

/**
 * 变量提升
 * JavaScript引擎的工作方式是,先解析代码,获取所有被声明的变量,然后再一行一行地运行.
 * 这造成的结果就是, 所有的变量的声明语句,都会被提升到代码的头部,这就叫做变量提升(hoisting)
 * 变量提升最对var命令声明有效.如果一个变量不是var命令声明的,就不会发生变量提升
 * **/

console.log(1);

var 长欢的对象 = undefined

/**
 * 单行注释除了使用'//'之外,还可以使用'<! --' 及 '-->'(要放在行首)
 * **/

/**
 * JavaScript中每个case代码块内部的break语句不能少,否则会接下去执行下一个case代码块,而不是跳出switch结构
 * **/

/**
 * switch语句后面的表达式与case语句后面的表达式,在比较运行结果时,采用的是严格相等运算符(===),而不是相等运算符9==)
 * 这意味着比较时不会发生类型转换
 *  **/


/**
 * JavaScript的数据类型
 * 数值(number):  整数和小数
 * 字符串(string): 字符组成的文本
 * 布尔值(bool):
 * undefined: 表示未定义或不存在. 即由于目前没有定义,所以此处暂时没有任何值
 * null: 表示无值, 相当于OC和Swift中的nil
 * object: 各种值组成的集合
 * **/


/**
 * 对象又分为三个子类型
 * 狭义的对象(object)
 * 数组(array)
 * 函数(function): JavaScript把函数当成一种数据类型,可以像其他类型的数据一样,进行赋值和传递
 * **/

/**
 * typeof运算符
 *
 *
 * **/

typeof 123
typeof "123"
typeof false

/**null 和 undefined
 * 在if语句中,它们都会被自动转为false, 相等运算符甚至直接报告两者相等
 * 但是在转为数值是,null为0, undefined为NaN
 * **/

typeof null //"object"


/**
 * 布尔值
 * 除了以下六个值被转为false,其他值都视为true
 * undefined/null/false/0/NaN
 * ""或''(空字符串)
 * **/
//空数组[]和空对象{}对应的布尔值都是true

/**
 * JavaScript内部,所有数字都是以64位浮点数形式存储,包括整数.
 * 1 和 1.0 是同一个数
 * **/

//当某些运算只有整数才能完成时,此时JavaScript会自动把64位浮点数转成32位整数,然后在进行运算

//0.1 + 0.2 === 0.3 //false
//(0.3 - 0.2) === (0.2 - 0.1) //false

//JavaScript中精度最多只能到53个二进制,及绝对值小于2的53次方的整数都可以精确表示


/**与数值相关的全局方法**/
/**  parseInt('字符串') : 将字符串转为整数
 *   如果字符串头部有空格,空格会被自动去除
 * **/

parseInt('123');

//parseInt方法还可以接收第二个参数,第二个参数指定 进制

/**
 *  parseFloat('字符串'): 将字符串转为浮点数
 * **/

/**
 * 字符串既可以用单引号''来表示,也可以用""来表示
 * 如果字符串中有单引号或双引号,需要在单引号或双引号前面加上反斜杠
 * **/

/**字符集
 * JavaScript使用Unicode字符集. 在JavaScript引擎内部,所有字符都用Unicode表示
 * **/
/**JavaScript内部都是以16位(2个字节)的UTF-16格式存储 **/

/** Base64 是一种编码方法,可以将任意字符转换成可打印字符. 使用这种编码方法,主要不是为了加密,而是为了不出现特殊字符,简化程序的处理
 *  JavaScript原声提供两个Base64相关方法
 *  btoa():  字符串或二进制值转为Base64编码
 *  atob(): Base64编码转为原来的编码
 * **/

/** 对象是JavaScript的核心概念,也是最重要的数据类型. JavaScript的所有数据都可以被视为对象
 *
 *  所谓对象就是一种无序的数据集合,由若干个"键值对"(key-value)构成
 *
 * **/

/**对象生成的三种方法**/
var o1 = {};

var o2 = new Object();

var o3 = Object.create(Object.prototype);

// 对象的所有键名都是字符串
var o = {
    'p': 'Hello World'
};


/**属性可以动态创建,不必在对象声明时就指定
 * **/

var dynamicO = {}
dynamicO.foo = 123

/** 对象的引用
 *  如果不同的变量名指向同一个对象,那么它们都是这个对象的引用,也就是指向同一个内存地址.
 *  修改其中一个变量,会影响到其他所有变量
 *  如果取消某一个变量对于原对象的引用,不会影响到另一个变量
 * **/

/** 原始类型的数据引用
 *  对于原始类型的数据的引用是值引用,也就是都是值拷贝
 * **/

/** JavaScript规定
 *  如果行首是大括号,则一律解释为语句(即代码块)
 *  如果要解释为表达式(对象),必须在大括号前加上圆括号
 * **/


/** 读取属性
 *  读取对象的属性,有两种方法,一种是使用点运算符,另一种是使用方括号运算符
 *  数值键名不能使用点运算符(因为会被当成小数点), 只能使用方括号运算符
 * **/

var propertyObj = {
    p: 'Hello World'
};

propertyObj.p
propertyObj['p']


/** 注意检查变量是否声明
 *  如果读取一个不存在的键,会返回undefined,而不是报错. 可以利用这一点来检查一个全局变量是否被声明
 * **/

if ('a' in window) {
    //变量a声明过
} else {
    //变量a未声明
}

/** 属性的赋值
 * 点运算符和方括号运算符,不仅可以用来读取数值,还可以用来赋值
 * JavaScript 允许属性的"后绑定". 也就是说,你可以在任意时刻新增属性,没必要在定义对象的时候就定义好属性
 * **/


/** 查看所有属性
 *  查看一个对象本身的所有属性,可以使用Object.keys 方法
 * **/

Object.keys(propertyObj)

/** delete命令
 *  该命令用于删除对象的属性,删除成功后返回true
 *  注意: 删除一个不存在的属性,delete不报错,而且返回true
 *  该命令只能删除对象本身的属性,无法删除集成的属性;
 *  该命令不能删除var命令声明的变量,只能用来删除属性. 因为var声明的全局变量都是顶层对象的属性,而且默认不得删除
 * **/

delete propertyObj.p
Object.keys(propertyObj)

/** in 运算符
 *  in 运算符用于检查对象是否包含某个属性(注意,检查的是键名,不是键值)如果包含就返回true,否则返回false
 *  in 运算符的一个问题是,它不能识别对象集成的属性, 可以用hasOwnProperty方法来判断
 * **/


/** for...in 循环
 * for...in循环用来遍历一个对象的全部属性
 * 注意点: 1. 它遍历的是所有可遍历的属性,会跳过不可遍历的属性
 * 2. 它不仅遍历对象自身的属性,还遍历集成的属性
 * **/

for (var i in propertyObj) {
    console.log(i)
}

/** with 语句
 * 它的作用是操作同一个对象的多个属性时,提供一些书写的方便
 * 不过它有一个弊病,就是绑定对象不明确
 * **/

with (propertyObj) {
    //statements
};

/** 数组
 *  任何类型的数据都可以放入数组
 *  本质上,数组属于一种特殊的对象.typeof运算符返回数组的类型是object
 *  JavaScript使用一个32位整数保存数组的元素个数.
 *  将数组清空的一个有效方法就是将length属性设为0
 *  数组的空位是可以读取的,返回undefined
 *  使用delete命令删除一个数组成员,会形成空位,并且不会影响length属性
 *
 *
 *  数组的某个位置是空位和某个位置是undefined是不一样的.如果是空位,在遍历的时候会被跳过
 * **/










